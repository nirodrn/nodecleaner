import os
import shutil
import sys
import logging
import platform
from pathlib import Path
from typing import List, Generator

# Configure logging
LOG_FILE = "deleted_node_modules.log"
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler(LOG_FILE),
        logging.StreamHandler(sys.stdout)
    ]
)

def setup_logging():
    """Ensures the log file is ready."""
    # The basicConfig above handles creation, but we can add a header if needed.
    pass

def scan_directories(root_path: str) -> Generator[Path, None, None]:
    """
    Scans the given root path for 'node_modules' directories.
    Efficiently skips traversing into 'node_modules' itself.
    """
    root = Path(root_path)
    if not root.exists():
        logging.error(f"Path does not exist: {root_path}")
        return

    print(f"Scanning {root_path} for node_modules... (this may take a while)")
    
    for dirpath, dirnames, filenames in os.walk(root):
        # Modify dirnames in-place to prevent os.walk from entering node_modules
        # This is the key efficiency step
        if 'node_modules' in dirnames:
            full_path = Path(dirpath) / 'node_modules'
            yield full_path
            dirnames.remove('node_modules')

def format_size(size_bytes: int) -> str:
    """Helper to format bytes into human readable string."""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if size_bytes < 1024.0:
            return f"{size_bytes:.2f} {unit}"
        size_bytes /= 1024.0
    return f"{size_bytes:.2f} PB"

def get_dir_size(path: Path) -> int:
    """Calculates total size of a directory."""
    total_size = 0
    try:
        for p in path.rglob('*'):
            if p.is_file():
                total_size += p.stat().st_size
    except Exception:
        pass # Ignore permission errors during size calc
    return total_size

def delete_directory(path: Path) -> bool:
    """
    Safely deletes a directory.
    Returns True if successful, False otherwise.
    """
    try:
        # Check if it's actually a directory to be safe
        if path.is_dir():
            # On Windows, sometimes read-only files cause issues. 
            # We can add an error handler if needed, but shutil.rmtree usually works.
            shutil.rmtree(path, ignore_errors=False)
            logging.info(f"Deleted: {path}")
            return True
        else:
            logging.warning(f"Not a directory, skipped: {path}")
            return False
    except Exception as e:
        logging.error(f"Failed to delete {path}: {e}")
        return False

def get_user_confirmation(prompt: str) -> bool:
    """Asks user for yes/no confirmation."""
    while True:
        choice = input(f"{prompt} (y/n): ").lower().strip()
        if choice in ['y', 'yes']:
            return True
        elif choice in ['n', 'no']:
            return False

def get_drives() -> List[str]:
    """Returns a list of available drives/partitions."""
    drives = []
    system = platform.system()
    
    if system == 'Windows':
        import string
        from ctypes import windll
        
        # Method 1: GetLogicalDrives bitmask
        bitmask = windll.kernel32.GetLogicalDrives()
        for letter in string.ascii_uppercase:
            if bitmask & 1:
                drives.append(f"{letter}:\\")
            bitmask >>= 1
    else:
        # Linux/macOS
        drives.append('/')
        # Check common mount points
        for mount_dir in ['/media', '/mnt', '/Volumes']:
            p = Path(mount_dir)
            if p.exists():
                for item in p.iterdir():
                    if item.is_dir(): # simplified check for mounted volumes
                        drives.append(str(item))
    
    return drives

def is_system_drive(path_str: str) -> bool:
    """Checks if the path is the system root (C:\ or /)."""
    path = Path(path_str).resolve()
    system = platform.system()
    
    if system == 'Windows':
        sys_drive = os.environ.get('SystemDrive', 'C:')
        # Check if path is exactly the system drive root (e.g. C:\)
        # We compare the drive letter and ensure it's the root
        return str(path).upper().startswith(sys_drive.upper()) and len(path.parts) == 1
    else:
        # On Linux/macOS, system root is /
        return str(path) == '/'

def main_menu():
    print("\n" + "="*40)
    print("   Node Modules Cleaner   ")
    print("="*40)
    
    while True:
        print("\nSelect a target to scan:")
        drives = get_drives()
        for i, drive in enumerate(drives, 1):
            print(f"{i}. {drive}")
        print("E. Enter a custom folder path")
        print("Q. Quit")
        
        choice = input("\nEnter your choice: ").strip().lower()
        
        if choice == 'q':
            sys.exit()
            
        target_path = ""
        
        if choice == 'e':
            target_path = input("Enter the folder path: ").strip()
        elif choice.isdigit():
            idx = int(choice) - 1
            if 0 <= idx < len(drives):
                target_path = drives[idx]
            else:
                print("Invalid number.")
                continue
        else:
            print("Invalid choice.")
            continue

        path_obj = Path(target_path)
        if not path_obj.exists() or not path_obj.is_dir():
            print("Invalid path. Please try again.")
            continue
            
        # SAFETY CHECK: Prevent full scan of system drive
        if is_system_drive(target_path):
            print("\n[!] SAFETY ALERT: You selected the System Drive.")
            print("    Scanning the entire system drive is restricted for safety.")
            print("    Please select a specific folder (e.g., Users/YourName/Projects).")
            continue

        break

    found_folders: List[Path] = []
    
    # Initial scan to populate list
    found_folders = list(scan_directories(target_path))
    
    if not found_folders:
        print("No 'node_modules' folders found.")
        return

    print(f"\nFound {len(found_folders)} 'node_modules' folders.")

    while True:
        print("\nOptions:")
        print("1. Dry Run (List all folders)")
        print("2. Delete All (with final confirmation)")
        print("3. Interactive Delete (Ask for each folder)")
        print("4. Exit")
        
        choice = input("\nEnter your choice (1-4): ").strip()

        if choice == '1':
            print("\n--- Dry Run Results ---")
            for folder in found_folders:
                print(f"[FOUND] {folder}")
            print(f"\nTotal found: {len(found_folders)}")
            print(f"Log file: {os.path.abspath(LOG_FILE)}")

        elif choice == '2':
            if get_user_confirmation(f"Are you SURE you want to delete ALL {len(found_folders)} folders? This cannot be undone."):
                deleted_count = 0
                for folder in found_folders:
                    print(f"Deleting {folder}...")
                    if delete_directory(folder):
                        deleted_count += 1
                print(f"\nOperation complete. Deleted {deleted_count} folders.")
                print(f"Check {LOG_FILE} for details.")
                break
            else:
                print("Operation cancelled.")

        elif choice == '3':
            print("\n--- Interactive Deletion ---")
            deleted_count = 0
            for folder in found_folders:
                if get_user_confirmation(f"Delete {folder}?"):
                    if delete_directory(folder):
                        print(f"Deleted.")
                        deleted_count += 1
                    else:
                        print("Failed to delete.")
                else:
                    print("Skipped.")
            print(f"\nInteractive session complete. Deleted {deleted_count} folders.")
            break

        elif choice == '4':
            print("Exiting...")
            sys.exit()
        
        else:
            print("Invalid choice.")

if __name__ == "__main__":
    try:
        main_menu()
    except KeyboardInterrupt:
        print("\nProgram interrupted by user. Exiting.")
        sys.exit()
